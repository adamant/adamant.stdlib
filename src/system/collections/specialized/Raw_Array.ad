namespace system.collections.specialized;

// Even though Raw_Array is not a primitve type, it is one of the types that the
// compiler will need to treat specially. For optimization, the compiler should
// be capable of optimizaing small arrays onto the stack the same way it
// optimizes objects onto the stack.

/// A `Raw_Array[T]` is a fairly thin wrapper around a pointer to a block of
/// memory. It doesn't carry a size.
public mut struct Raw_Array[T]$self
{
    // This is needed to allow pointers to references
    private struct Element[T]
    {
        public unsafe var value: T = uninitialized;
    }

    private let elements: @Element[T];

    public new(count: size)
    {
        if count > 0
            { .elements = allocate[Element[T]](count); }
    }

    private init(elements: @Element[T])
    {
        .elements = elements;
    }

    public unsafe fn at(mut self, index: size) -> ref var T
    {
        return unsafe(ref var (elements+index)^.value);
    }

    public unsafe fn at(self, index: size) -> ref T
    {
        return unsafe(ref (elements+index)^.value);
    }

    public fn slice(mut self, index: size) -> mut Raw_Array[T] $< t
    {
        return init Raw_Array[T](elements+index);
    }

    public fn slice(self, index: size) -> Raw_Array[T] $< t
    {
        return init Raw_Array[T](elements+index);
    }

    // TODO this is strange, do they explicitly call delete?
    public unsafe delete()
    {
        unsafe(free(elements));
    }
}
